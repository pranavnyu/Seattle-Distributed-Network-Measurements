"""
<Program Name>
  dnsquery.repy

<Date Created>
  February 20, 2010

<Author(s)>
  Pranav Raj Tyagi
  pt992@nyu.edu

<Major Edits>
  None

<Purpose>
  Implements a function to query a name server for the INTERNET-class A recordof a FQDN
  and replies in a 'tuple'

<Notes>
  Implement a function to query a name server for the INTERNET-class A record of a FQDN, 
  and return the reply in a `tuple`, as Python's `socket.gethostbyname_ex` does.
    
  `dnsquery.gethostbyname_ex(name)`
  Use `dnscommon` to construct the UDP datagram contents, 
  and add code to your function to send the query and receive the reply. 
  Write your code so as to use a global definition, NAME_SERVER_IP="8.8.8.8", 
  which is the server to be queried per default. Compare your results with `dig @8.8.8.8 FQDN`.

  ------------
"""

#imports dnscommon.r2py file from repyv2 library using dylink.r2py
dnscommon = dy_import_module("dnscommon.r2py")


def dns_connection(client_ip,client_port,destip, destport ,dns_dictionary):
  '''
 <Arguments>
    dns_dictionary
      A formatted dictionary describing a DNS packet of the followin form:

  {
    'raw_data':           <long string> (network raw)
    'remote_ip':          string (formatted unicode, IP Address)
    'remote_port':        integer
    'communication_id'         string (network raw)
    'query_response'           boolean
    'operation_code'           integer
    'authority_advisory'       boolean
    'truncation'               boolean
    'recursion_desired'        boolean
    'recursion_accepted'       boolean
    'z'                        boolean
    'authentic_data'           boolean
    'checking_disabled'        boolean
    'error_code'               integer (4 bit)
    'question_count'           integer (16 bit)
    'answer_count'             integer (16 bit)
    'authority_record_count'   integer (16 bit)
    'additional_record_count'  integer (16 bit)   )
    'questions': array of dictionaries containing:
        'name'                  string (formatted unicode, IP Address)
        'type'                  string (formatted unicode, eg A, AAAA, MX)
        'class'                 string (formatted unicode, eg IN, HE, CH)
    'answers': array of dictionaries containing:
        'name'                  string (formatted unicode, IP Address)
        'type'                  string (formatted unicode, eg A, AAAA, MX)
        'class'                 string (formatted unicode, eg IN, HE, CH)
        'time_to_live'          integer (seconds, 32 bit)
        'answer_data'           string (formatted unicode, RR format)
                                                   Note that the length and
                                                   format of this field
                                                   will vary based on the
                                                   type of the answer RR.
                                                   This will be *exactly*
                                                   the return data from
                                                   the DHT server.
  }


  '''
  conn = openconn(desthost, destport, client_ip, client_port, timeout = 5)
  if conn is True:
    converted_packet = convert_dictionary_to_packet(dns_dictionary)
    
    sendmess(desthost, destport, converted_packet, client_ip, client_port)

    commhandle = recvmess(client_ip, client_port , _message_received)

    return commhandle
    
def _message_received(client_ip, client_port, converted_packet, 
                                  connhandle):
  packet_dict = _process_query(client_ip, client_port, converted_packet, 
                                   connhandle)

  if packet_dict != None:
    sendmess(client_ip, client_port, packet_dict)


def _process_query(client_ip, client_port, converted_packet, connhandle):
  packet_dict = dnscommon.convert_packet_to_dictionary(con)
  packet_dict['remote_ip'] = client_ip
  packet_dict['remote_port'] = client_port
  return packet_dict

  











